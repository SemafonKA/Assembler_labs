.386
.MODEL FLAT, STDCALL
OPTION CASEMAP: NONE
; прототипы внешних функций (процедур) описываются директивой EXTERN, 
; после знака @ указывается общая длина передаваемых параметров,
; после двоеточия указывается тип внешнего объекта – процедура
EXTERN  GetStdHandle@4: PROC		; Функция получения дескрипторов ввода (-10) и вывода (-11) данных в консоль
EXTERN  WriteConsoleA@20: PROC
EXTERN  ReadConsoleA@20: PROC
EXTERN  lstrlenA@4: PROC			; функция определения длины строки
EXTERN  CharToOemA@8: PROC			; хз пока что это
EXTERN  ExitProcess@4: PROC			; функция выхода из программы

.CONST								; Сегмент констант
	const_base	dword 16	
.DATA								; сегмент данных
	; Переменные для процедуры HexToDecimal@12
	intPtr		dword 0					; Указатель на целое число в функции
	strPtr		dword 0					; Указатель на начало функции
	i			dword 0					; Переменная i 
	p			dword 0					; Переменная p
	k			byte  0					; Переменная под буквы

	; Переменные для процедуры DecimalToStr@16
	num			sdword 0				; Переданное число для преобразования
	bufPtr		dword 0					; Указатель на буфер
	bufSize		dword 0					; Размер буфера
	factSizePtr	dword 0					; Указатель на фактический размер числа в строке

	; Переменные для основной программы
	din			dword ?					; Дескриптор ввода
	dout		dword ?					; Дескриптор вывода

	lens		dword ?					; Переменная для количества выведенных символов
	impStr		byte  "Введите 16-ричное число: ", 13, 10, 0
	impStrLen	dword ?					; Переменная для количества символов в строке impStr
	buf			byte 200 dup (?)		; Буфер для ввода, размер 200 символов

	firstNum	sdword 0				; Переменная с первым введённым числом
	secondNum	sdword 0				; Переменная со вторым введённым числом
.CODE								; сегмент кода 
MAIN PROC; начало описания процедуры с именем MAIN
	push -10		; Получаем дескриптор ввода
	CALL GetStdHandle@4
	mov din, eax

	push -11		; Получаем дескриптор вывода
	CALL GetStdHandle@4
	mov dout, eax


	mov eax, offset impStr
	push eax			; Куда записываем результат 
	push eax			; Какую строку конвертируем
	call CharToOemA@8	; Конвертируем символы строки в oem

	push offset impStr
	call lstrlenA@4	; Получаем длину строки impStr
	mov impStrLen, eax

	; Вводим первое число
;#region 
	PUSH 0					; Какой-то ещё параметр
	PUSH OFFSET lens		; Указатель на число, куда запишется фактическое число выведенных символов
	PUSH impStrLen			; Длина строки
	PUSH OFFSET impStr		; Указатель на строку
	PUSH dout				; Дескриптор вывода в консоль
	CALL WriteConsoleA@20	; Выводим текст в консоль

	push 0					; Какой-то ещё параметр
	push offset lens		; Указатель на фактическую длину считанных параметров
	push 200				; Размер буфера
	push offset buf			; Указатель на буфер
	push din				; Дескриптор ввода
	call ReadConsoleA@20	; Считываем число с консоли

	sub lens, 2				; Убираем из строки с числом символы переноса и сброса каретки
	push offset firstNum
	push lens
	push offset buf
	call HexToDecimal@12
;#endregion

	; Вводим второе число
;#region
	PUSH 0					; Какой-то ещё параметр
	PUSH OFFSET lens		; Указатель на число, куда запишется фактическое число выведенных символов
	PUSH impStrLen			; Длина строки
	PUSH OFFSET impStr		; Указатель на строку
	PUSH dout				; Дескриптор вывода в консоль
	CALL WriteConsoleA@20	; Выводим текст в консоль

	push 0					; Какой-то ещё параметр
	push offset lens		; Указатель на фактическую длину считанных параметров
	push 200				; Размер буфера
	push offset buf			; Указатель на буфер
	push din				; Дескриптор ввода
	call ReadConsoleA@20	; Считываем число с консоли

	sub lens, 2				; Убираем из строки с числом символы переноса и сброса каретки
	push offset secondNum
	push lens
	push offset buf
	call HexToDecimal@12
;#endregion
	
	mov eax, firstNum
	sub eax, secondNum
	mov firstNum, eax		; Вычитаем второе число из первого, сохраняем в первом

	push 0
	call ExitProcess@4
MAIN ENDP; завершение описания процедуры с именем MAIN


; Процедура перевода десятичного числа в строку
; На вход число, указатель на буфер, длина буфера, указатель на фактическую длину числа
DecimalToStr@16 proc
	push ebp		; Сохраняем прежнее значение бегунка по стеку данных (чтобы в конце его вернуть)
	mov ebp, esp	; Записываем в бегунок указатель на вершину стека данных
	add ebp, 8		; Первые 4 байта в стеке - указатель прежнего бегунка, вторые 4 байта - указатель для возврата с процедуры, поэтому их скипнем

	mov eax, [ebp]	; Извлекаем указатель на фактическую длину числа
	mov factSizePtr, eax
	mov eax, [ebp+4]; Извлекаем длину буфера
	mov bufSize, eax
	mov eax, [ebp+8]; Извлекаем указатель на буфер
	mov bufPtr, eax
	mov eax, [ebp+12]; Извлекаем число
	mov num, eax

	mov eax, factSizePtr	; Зануляем переменную фактического размера
	mov ebx, 0
	mov [eax], ebx

	; Перебор всего числа, запись строки в обратном порядке
	; Если число отрицательное, то дописать минус в конец
	; Переворот строки путём обмена крайних символов на одном расстоянии

	pop ebp			; Возвращаем прежнее значение бегунка
	ret	16			; Выходим из процедуры, при этом говорим напрямую, что после выхода нужно сдвинуть указатель на 4 элемента:
DecimalToStr@16 endp

; Процедура преобразования строки с 16-ричным числом в 10-ричное 4-байтное
; Принимает на вход указатель на строку с 16-ричным числом, размер строки (4 байта) и указатель на переменную целую 4 байтную (куда запишется число)
HexToDecimal@12 proc	; Начало процедуры 
	push ebp		; Сохраняем прежнее значение бегунка по стеку данных (чтобы в конце его вернуть)
	mov ebp, esp	; Записываем в бегунок указатель на вершину стека данных
	add ebp, 8		; Первые 4 байта в стеке - указатель прежнего бегунка, вторые 4 байта - указатель для возврата с процедуры, поэтому их скипнем

	mov eax, [ebp+8]
	mov intPtr, eax		; Записали указатель на 4-байтное целое
	mov eax, [ebp+4]
	mov ecx, eax		; Записали длину строки, ECX - итератор цикла
	mov eax, [ebp]
	mov strPtr, eax		; Записали указатель на начало строки

	mov eax, intPtr
	mov ebx, 0
	mov [eax], ebx		; Записали по адресу intPtr значение ноль

	mov i, 0
	mov p, ecx
	dec p
	
loopBegin1: 			; Метка начала цикла
	
		mov eax, strPtr
		mov bh, [eax]
		mov k, bh		; записываем текущую букву в k
		sub k, '0'

		cmp k, 9			; Если k меньше или равно 9, то
		jbe getToNum		; Переход к метке getToNum

		mov bh, [eax]
		mov k, bh
		sub k, 'A'
		add k, 10

	getToNum:

		push ecx			; Записываем итератор внешнего цикла в стек
		mov ecx, p

		mov eax, 1			; Инициализируем eax для умножения
		cmp ecx, 0
		je powLoopSkip		; Если ecx = 0, то пропускаем цикл возведения в степень
	loopPowBegin1:
		; здесь должно быть умножение аля возведение в степень
		mul const_base
	loop loopPowBegin1

	powLoopSkip:
		pop ecx				; Возвращаем прежний итератор из стека
		mul k				; Умножаем получившийся eax на k

		mov ebx, intPtr
		add [ebx], eax		; Добавляем в переменную по intPtr полученное на итерации число

		add strPtr, 1		; Смещаем строку на символ
		inc i
		dec p
	loop loopBegin1

	pop ebp			; Возвращаем прежнее значение бегунка
	ret	12			; Выходим из процедуры, при этом говорим напрямую, что после выхода нужно сдвинуть указатель на 3 элемента:
					; 4 байта - указатель строки, 4 байта - указатель на длину строки, 4 байта - на число
HexToDecimal@12 endp

END MAIN; завершение описания модуля с указанием первой выполняемой процедуры
